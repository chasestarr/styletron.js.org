import Layout from "../components/layout";

export default Layout;

# Use with React

**This page describes the motivation of why to use Styletron and React together.** It also goes over some APIs that `styletron-react` provides and pitfalls that you can run into. If you need to setup Styletron for your project, please check the [Getting Started](/getting-started) page!

1. [Motivation](#motivation)
2. [Styled Components](#styled-components)
3. [Props Filtering](#props-filtering)
4. [`$as` prop](#as-prop)
5. [`$ref` prop](#ref-prop)

## Motivation

**React components are independent and reusable pieces of UI**. They accept props and return a description of what should appear on the screen - typically, in a form of HTML markup. For long time, the styles were left outside and done by different means. You probably wrote or saw this code before:

```jsx live
class MyApp extends React.Component {
  constructor() {
    this.state = {
      isActive: false
    };
  }
  render() {
    const { isActive } = this.state;
    return (
      <button
        className={`btn ${isActive ? "btn-active" : ""}`}
        onClick={() => {
          this.setState(prev => ({ isActive: !prev.isActive }));
        }}
      >
        It is {isActive ? "on" : "off"}!
      </button>
    );
  }
}
```

It is pretty clear that `MyApp` renders a button that can be in active/inactive state. **What's not clear is how the resulting button looks like**. We can tell it uses `.btn` and `.btn-active` CSS classes but we don't know where those classes are defined, what rules they apply or what the overall workflow story is. Suddenly, our encapsulated piece of UI heavily relies on a code that lives outside of it. **It lost independence and isolation**. We can't just simply copy&paste it into a different project and expect it to work. **It's not portable**.

To make it even more awkward, **the component state should directly control what CSS rules are applied**: _When the button is active, its background should be blue_. We have to joggle class names and glue together the `className` prop. It gets even less readable if there are more states. We call this concept **dynamic styling**. We have a need to map props/state directly into the resulting styles.

But I have great news for you! **We can solve all the issues described above by using inline styles**:

```jsx live
class MyApp extends React.Component {
  constructor() {
    this.state = {
      isActive: false
    };
  }
  render() {
    const { isActive } = this.state;
    return (
      <button
        style={{
          padding: "0.5em 1em",
          color: isActive ? "#fff" : "#000",
          background: isActive ? "#276ef1" : "none",
          fontSize: "1em",
          borderRadius: "4px",
          border: "1px solid #aaa"
        }}
        onClick={() => {
          this.setState(prev => ({ isActive: !prev.isActive }));
        }}
      >
        It is {isActive ? "on" : "off"}!
      </button>
    );
  }
}
```

All the styles are now encapsulated in the component. We can clearly see what rules are being used. We don't have to worry about a special build process. **Oh, and no `className` joggling either - we don't even have classNames anymore!** But, inline styles have some very serious limitations: You can't use pseudo selectors as `:hover` or media queries.

If there was only a way how to get the best of both worlds. ðŸ¤”

## Styled Components

**Styletron provides an API and developer experience similar to inline styles but without any drawbacks**. Let's do the button example again, but this time with Styletron:

```jsx live
import { styled } from "styletron-react";

class MyApp extends React.Component {
  constructor() {
    this.state = {
      isActive: false
    };
  }
  render() {
    const Button = styled("button", props => ({
      padding: "0.5em 1em",
      color: props.$isActive ? "#fff" : "#000",
      background: props.$isActive ? "#276ef1" : "none",
      fontSize: "1em",
      borderRadius: "4px",
      border: "1px solid #aaa",
      ":hover": {
        background: props.$isActive ? "green" : "yellow"
      }
    }));
    const { isActive } = this.state;
    return (
      <Button
        $isActive={isActive}
        onClick={() => {
          this.setState(prev => ({ isActive: !prev.isActive }));
        }}
      >
        It is {isActive ? "on" : "off"}!
      </Button>
    );
  }
}
```

It looks somewhat similar to the inline style example. The styles are still defined inside of the component but we are doing an extra step now - **we are creating a styled component**.

The `styled` function expects two arguments:

- **Element type** - What underlying DOM element should be used. In our case, we chose `button`.
- **Style function / object** - To describe the styles. It can be a plain styled object or a function that returns a styled object. The function gets `props`. That's useful if your styles dynamic needs to be dynamic (derived from `props`).

For styling properties, we use camelCase and there are some other subtle differences described in [Concepts](/concept). We can also use pseudo classes as `:hover`, that would not be possible with inline styles.

Once the styled component is created, we can render it as any other React component. **We don't need to specify `style` or `className` prop**. The styled component already did that for us on the background - Styletron created a bunch of CSS classes and "glued" them to the `<Button />` component. Check the [Home page example](/#example) for more details.

One thing that seems a bit off is `$isActive` prop. Why do we use `$` when we could simply call it `isActive` instead?

## Props Filtering

Note that we are passing two props into our styled `Button` component

```jsx
<Button $isActive={/*...*/} onClick={/*...*/}>...</Button>
```

but they have very different purposes:

- `$isActive` is used to determine the correct (dynamic) styling
- `onClick` is an event handler that needs to be passed to the underlying `button` element, we don't use it for styling purposes

**Styletron doesn't see the difference.** It doesn't know if the passed prop is going to be used only in the `styled` function or if it should be passed all the way down to underlying element. **What happens if all props are passed to the DOM element?** This error:

> Warning: React does not recognize the `$isActive` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `$isactive` instead. If you accidentally passed it from a parent component, remove it from the DOM element.

So you need to help Styletron a bit. **All props starting with `$` are filtered out and not passed to the underlying element**. Styletron could whitelist all DOM attributes and filter out other props but that's [considered as an anti-pattern](https://twitter.com/dan_abramov/status/822526388557250560?lang=en). Mostly, because it would make the bundle bigger and it's bad for performance.

The warning message above was manufactured since `$isActive` is filtered out by Styletron.

## `$as` prop

`$as` has a special meaning. **It allows you to swap the underlying element**:

```jsx live
() => {
  const Text = styled("p", { color: "red" });
  return (
    <React.Fragment>
      <Text>Rendered as a paragraph</Text>
      <Text $as="button">Rendered as a button</Text>
    </React.Fragment>
  );
};
```

This can be especially useful when you need to swap between `a` and `button` or `h1`, `h2`, `h3`. You don't need to create multiple styled components.

## `$ref` prop

What are [React refs](https://reactjs.org/docs/refs-and-the-dom.html)?

> In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.

**Refs is an escape hatch so you can directly modify the instance of a React component**. For example, we have an input and button and we want to focus the input when the button is clicked:

```jsx live
class MyApp extends React.Component {
  constructor() {
    this.inputRef = React.createRef();
  }
  render() {
    return (
      <React.Fragment>
        <input ref={this.inputRef} />
        <button onClick={() => this.inputRef.current.focus()}>
          Focus input
        </button>
      </React.Fragment>
    );
  }
}
```

However, if `input` is not just a simple input but styled component `<Input />` this will not work:

```jsx
import { styled } from "styletron-react";

const Input = styled("input", { background: "#FFE1A5" });

// ...
<Input ref={this.inputRef} />;
// ...
```

React will complain:

> Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?

**`styled` creates a function component** and not class based component. **Function components can't accept a ref**. React gives a great suggestion to library maintainers to forward refs with [React.forwardRef](https://reactjs.org/docs/forwarding-refs.html) API. This is a fairly new feature (React v16.3). Most likely, Styletron [will adopt it](https://github.com/styletron/styletron/issues/253) in the next major version. In meantime, Styletron provides an alternative ref forwarding API through the `$ref` prop:

```jsx live
import { styled } from "styletron-react";

class MyApp extends React.Component {
  constructor() {
    this.inputRef = React.createRef();
  }
  render() {
    const Input = styled("input", { background: "#FFE1A5" });
    return (
      <React.Fragment>
        <Input $ref={this.inputRef} />
        <button onClick={() => this.inputRef.current.focus()}>
          Focus input
        </button>
      </React.Fragment>
    );
  }
}
```

Just rename `ref` to `$ref`. That's it!
